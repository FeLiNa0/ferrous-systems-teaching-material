= WebAssembly

link:./index.html[Table of Contents]


== What?

WebAssembly enables running Rust (among others) in Javascript environments like the web browser.

It is the successor to asm.js in many ways.

It is currently a developing standard and is often not enabled by default.

== Gotcha

WebAssembly is still not widely supported and has a number of rough edges.

== Installing

Setup is a bit unrefined at this moment, but it should improve in the future.

* Fetch `emsdk` from http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html[emscripten].
* Unpack it somewhere sensible.
* Navigate to the directory in your terminal.

== Installing: `emcc`

[source,bash]
----
include::./1.bash[]
----

The output of the third command will offer instructions for what to add to `$PATH` if desired.

> We use `incoming` to utilize the latest refinements.

== Installing: `emcc`

The versions of the toolchain are quite important. Verify there are no errors running the following:

[source,bash]
----
include::./2.bash[]
----

== Installing: `rustup` Target

`rustup` allows installing multiple compilation targets.

[source,bash]
----
include::./3.bash[]
----

== Standalone Executable

== Standalone Executable

[source,bash]
----
include::./4.bash[]
----

[source,rust]
----
include::./5.rs[]
----

== Standalone Executable

[source,bash]
----
include::./6.bash[]
----

This will create a directory structure like so:

[source]
----
include::./7.output[]
----

== Standalone Executable

Once we generate the `wasm` and `js` we want to place them in with a `site` folder. We can use a `Makefile` for this.

[source,makefile]
----
include::./8.makefile[]
----

== Standalone Executable

Create `site/index.html`:

[source,html]
----
include::./9.html[]
----

== Standalone Executable

Running `python3 -m http.server` or equivalent, browsing to `localhost:8000/site`, and opening the console yield the following output:

[source]
----
include::./10.output[]
----

== Rust from JS

== Rust from JS

Exporting functions for use in Javascript is a bit more complicated.

Additionally, interactions must be handled like interactions to C.

== Rust from JS

The nightly channel is currently necessary to get this to work properly:

[source,bash]
----
include::./11.bash[]
----

== Rust from JS

[source,bash]
----
include::./12.bash[]
----

[source,rust]
----
include::./13.rs[]
----

== Rust from JS

We can use the same Makefile as before.

[source,makefile]
----
include::./8.makefile[]
----

== Rust from JS

The `onRuntimeInitialized` hook for `Module` defines what is called after the WebAssembly is loaded.

[source,html]
----
include::./14.html[]
----

== Rust from JS

Running `python3 -m http.server` or equivalent, browsing to `localhost:8000/site`, and opening the console yield the following output:

[source]
----
include::./15.output[]
----

== JS from Rust

== JS from Rust

Calling JS code from Rust has similar complications.

It is done primarily through passing the `+--js-library+` flag at link time, which requires the nightly channel of rust.

Passing numerics is relatively simple, but passing more complex things like strings requires extra effort.

== JS from Rust

Returning a string for Rust code:

[source,javascript]
----
include::./17.js[]
----

== JS from Rust

Calling the Javascript function:

[source,rust]
----
include::./18.rs[]
----

== DOM Interaction

There is a https://github.com/tcr/rust-webplatform[WebPlatform crate] to explore and contribute to.

[source,rust]
----
include::./19.rs[]
----

== Future

WebAssembly is rapidly becoming more refined and mature. Rust's integration is also under active work.

Keep your eyes peeled for more, better support!
