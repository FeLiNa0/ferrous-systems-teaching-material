= Asynchronous Programming

link:./index.html[Table of Contents]

== Concurrency

[.stretch]
[mermaid, format=svg]
....
graph TD
  A[Concurrency] --> B[Asynchrony]
  A --> C[Parallelism]
....

== Parallelism

* Running on multiple OS/hardware threads
* Pre-emptive multitasking
* Handled by OS

== Parallelism

* Running on multiple OS/hardware threads
* Pre-emptive multitasking
* Handled by OS
* Best for: *CPU-bound workloads*

== Asynchrony

* Lightweight tasks
* Interleaving tasks
* Needs user-level scheduler (executor)

== Asynchrony

* Lightweight tasks
* Interleaving tasks
* Needs user-level scheduler (executor)
* Best for: *I/O-bound workloads*

== Asynchronous Advantages

* Many thousands of tasks simultaneously
* Lower overhead per-task
* Many I/O requests in flight

== Asynchrony in Rust

Example: making an HTTP request

[source,rust]
----
include::./is_website_up.rs[]
----

== Async

* 'async' marks a function as asynchronous
* Changes the return type to a Future
* Running function creates the future

== Await

* '.await' creates an await point
* Yields control back to the executor
* '.await' returns when the future has finished

== Asynchrony in Rust

[source,rust]
----
include::./fetch_into_string.rs[]
----

* Question: How many tasks are running concurrently?

== Asynchrony in Rust

* By default no asynchrony in async/await
* Needs async operators
* Most common:
  * Join: wait for all async tasks to complete
  * Select: wait for one async task to complete

== Join example

[source,rust]
----
include::./join.rs[]
----

== Select example

[source,rust]
----
include::./select.rs[]
----

== Make Futures Go

* `Future` s are *lazy*
* executor (single-threaded or multi-threaded)

== Make Futures Go

Do lines 1 and 2 print?

[source,rust]
----
include::./lazy.rs[]
----

== Running tasks

[source,rust]
----
include::./block_on.rs[]
----

== `block_on`

* takes a future
* blocks the current thread until the future is resolved
* async runtimes provide this method

== Laziness in Detail

== Example: JavaScript

* Eager execution model
* Other languages behave similarly (C#, Python, Swift, Kotlin, etc.)
* JavaScript calls its futures "Promises"

[.columns.is-vcentered]
== Rust Futures vs JavaScript Promises

[.column]
[source,rust]
----
include::./futures_vs_promises.rs[]
----

[.column]
[source,javascript]
----
include::./futures-vs-promises.js[]
----

[.columns.is-vcentered]
== Eager Execution (JavaScript and many other languages)

[.column]
[source,javascript]
----
include::./futures-vs-promises.js[]
----

[.column]
[mermaid, format=svg]
....
sequenceDiagram
  participant main
  participant task
  participant subtask
  Note right of main: console.log("before promise")
  main->>task: let promise = task()
  Note right of task: console.log("> before subtask")
  task->>subtask: subtask()
  Note right of subtask: console.log("> > subtask")
  subtask-->>task: a promise is prepared
  task-->>main: a promise is prepared
  Note right of main: console.log("promise is created")
  main->>task: await
  task->>subtask: await
  subtask-->>task: return
  Note right of task: console.log("> after subtask")
  task-->>main: return
  Note right of main: console.log("promise is awaited")
....

[.columns.is-vcentered]
== Eager Execution (JavaScript and many other languages)

[.column]
[source,javascript]
----
include::./futures-vs-promises.js[]
----

++++
<div class="column">
++++
Output: JavaScript
----
before promise

> before subtask

> > subtask

promise is created

> after subtask

promise is awaited
----
++++
</div>
++++

== Eager Execution: Takeaways

* as soon as async function is called it starts executing
* runs till the first `await` point
* inner async functions run their code, too, and stop at `await`
* an async function with no `await` inside will execute its full body eagerly

[.columns.is-vcentered]
== Lazy Execution: Rust Futures

[.column]
[source,rust]
----
include::./futures_vs_promises.rs[]
----

[.column]
[mermaid, format=svg]
....
sequenceDiagram
  participant main
  participant task
  participant subtask
  Note right of main: println!("before future")
  Note right of main: let future = task()
  Note right of main: println!("future is created")
  main->>task: await
  Note right of task: println!("> Before subtask")
  Note right of task: subtask()
  task->>subtask: await
  Note right of subtask: println!("> > subtask")
  subtask-->>task: return
  Note right of task: println!("> After subtask")
  task-->>main: return
  Note right of main: println!("future is awaited")
....

[.columns.is-vcentered]
== Lazy Execution: Rust Futures

[.column]
[source,rust]
----
include::./futures_vs_promises.rs[]
----

++++
<div class="column">
++++
Output: Rust
----
before future

future is created

> Before subtask

> > subtask

> After subtask

future is awaited
----
++++
</div>
++++

[.columns.is-vcentered]
== Rust Futures vs JavaScript Promises

[.column]
[source,rust]
----
include::./futures_vs_promises.rs[]
----

++++
<div class="column">
++++
Output: Rust
----
before future

future is created

> Before subtask

> > subtask

> After subtask

future is awaited
----
Output: JavaScript
----
before promise

> before subtask

> > subtask

promise is created

> after subtask

promise is awaited
----
++++
</div>
++++

[.column]
[source,javascript]
----
include::./futures-vs-promises.js[]
----

== Lazy Future Execution: Takeaways

* no code is being run until a future is `await` ed
* `await` triggers the whole chain to execute
* no "fire now, `await` later" workflow

== Runtimes

[source,rust]
----
include::./async_main_1.rs[]
----

== "Async Main" Pattern

[source,rust]
----
include::./async_main_2.rs[]
----

== Why Many Runtimes

* `tokio` - a high-performant multithreaded runtime
* `embassy` - a tiny single-threaded runtime for microcontrollers
* ...
* task executor, scheduler, non-blocking IO APIs

== Multithreading

* `block_on` runs tasks on a single tread
* you can tell runtime that ta given async block can run on a separate thread

[source,rust]
----
include::./task_spawn.rs[]
----
* other runtimes may have similar APIs

== Multithreading

Use concurrency primitives to pass or share data between async blocks:
* `Arc`, `Mutex`, channels, etc.

== `std::sync::Mutex` vs `<runtime>::Mutex`

* use `std::sync::Mutex` if critical section is short and doesn't have `await` s in it.
* use runtime's `Mutex` otherwise.

== Compatibility

* thin compatibility layer based on `std::future::Future`
* enough to support `async await` syntax only
* standardization of other APIs is in progress

== Reading an async stream

* no async iterators in the language yet
* use `while-let-await` loop:

[source,rust]
----
include::./async_stream_read.rs[]
----

== Async Traits

* a big missing piece of the puzzle
* cannot be implemented in Rust yet:

[source,rust]
----
include::./async_trait.rs[]
----
* thus cannot describe common traits for async versions of `fs`, `net`, etc.
* each runtime brings their own implementations!

== Libraries

* has to either choose one runtime to work on
* or include adapters for several runtimes
* `tokio` has the largest ecosystem

== Future of Async in Rust

* async traits!
* standardize more APIs to remove the need to pick runtimes to support for libraries
* async iterators
* streams
* the progress is slow yet steady
