= Exercise: calculator
:icons: font
:source-highlighter: rouge

In this exercise, we will implement a simple calculator.

You will learn:

* How to write a simple Rust library
* How to interact with borrowed and owned memory, especially how to take ownership
* How to handle cases using the `match` syntax
* How to create a safe parser in Rust manually

The library does not handle I/O.
It'll serve us as a pocket-sized "`big`" project.

== Syntax Specification

To simplify parsing, we will use postfix notation:

[source,python]
----
expr = number
     | expr expr '+'
     | expr expr '-'
     | expr expr '*'
     | expr expr '/'
     | expr 'sqr'      # Squares expression
----

Here are some examples:

|===
|Postfix notation | Infix notation | Value

|`92`                    | `92`               | 92
|`40 2 +`                | `40 + 2`           | 42
|`1 3 + 2 /`             | `(1 + 3) / 2`      | 2
|`3 sqr 4 sqr + 5 sqr -` | `3^2 + 4^2 - 5^2`  | 0
|===

== Task

. Create a library project called `calc` (`cargo new --lib calc`).
. Define data structures for representing AST of expressions (`Expr`) and parsing errors (`ParseError`).
  While it is possible to directly evaluate the expression during parsing, we ask you to first parse it into the AST.
  AST structure should be recursive -- an `Expr` has two child `Expr`s. 
. Read the documentation for `str` (primitive), especially `split`.
. Define function for parsing expressions:
+
[source,rust]
----
fn parse(input: &str) -> Result<Expr, ParseError> {
    todo!()
}
----
. To parse an expression in postfix notation, make a stack of expressions:
+
[source,rust]
----
let mut stack: Vec<Expr> = Vec::new();
for token in tokens {
    ...
}
assert_eq!(stack.len(), 1);
stack.pop().unwrap()
----
+
If the next token of the input is a number, push a number expression to the stack.
If the next token is an operator (`-`, `+`, `/`, `sqr`), pop one or two arguments from the stack and push the composite expression back.
. Write tests for parsing.
. Define function for evaluating expressions:
+
[source,rust]
----
fn eval(expr: &Expr) -> Result<i64, EvalError> {
    todo!(),
}
----
. Finishing touches:
** implement `std::error::Error` for you error types,
** implement `FromStr` for `Expr`,
** make `eval` a method,
** run `clippy` on your codebase,
** run `rustfmt` on your codebase,

== Help

This section gives partial solutions to look at or refer to.

In general, we also recommend to use the Rust documentation to figure out things you are missing to familiarise yourself with it. If you ever feel completely stuck or that you haven't understood something, please hail the trainers quickly.

=== Getting Started

Create a new Cargo project, check the build and the test setup:

[source]
----
$ cargo new --lib calc
$ cd calc
$ cargo build
$ cargo test
----

=== Appropriate data structures

The appropriate data structure kinds for `Expr` and `Error` are:

[source,rust]
----
pub enum Expr {
    //....
}

pub enum ParseError {
    //....
}

pub enum EvalError {
    //....
}
----

The reason is that both describe can take multiple cases, which can be listed.

=== Full Data definition

Here's a full definition:

[source,rust]
----
#[derive(Debug)]
enum Expr {
    Number(i64),
    Square(Box<Expr>),
    BinOp {
        kind: BinOpKind,
        lhs: Box<Expr>,
        rhs: Box<Expr>,
    },
}

#[derive(Debug)]
enum BinOpKind {
    Add, Sub, Mul, Div
}

#[derive(Debug)]
enum ParseError {
    UnexpectedToken,
    LeftoverInput
}

enum EvalError {
    DivisionByZero
}
----
