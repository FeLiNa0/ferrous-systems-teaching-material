The multithreaded mailbox
-------------------------

Bring your TCP server and the protocol we wrote yesterday together.

1. Implement multithreading
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Per connection:

1.  spawn a thread using `std::thread::spawn`
2.  wrap the `VecDeque` in a `std::sync::Mutex` and an `std::sync::Arc`
to pass it around


== Note

To send and receive messages, you can either use `nc` or `telnet`. Alternatively, you can use the client provided: https://github.com/ferrous-systems/rust-three-days-course/tree/master/example/redisish-client

Usage:

----
cargo run --bin publish -- "This is my message"
cargo run --bin retrieve
----

= Help

The help section omits Step 4, "proper error handling" and makes the server panic if bad data is received.

== Parsing a command from a TCPStream

We highly recommend moving reading and parsing into its own function.

[source,rust]
----
// At the top of your file
use std::net::{TcpListener,TcpStream};
use std::io::prelude::*;
use redisish;

fn read_command(stream: &mut TcpStream) -> redisish::Command {
    let mut read_buffer = String::new(); <1>
    stream.read_to_string(&mut read_buffer).unwrap(); <2>

    redisish::parse(&read_buffer).unwrap(); <3>
}
----

<1> Allocate a read buffer.
<2> Read all data into the buffer until the client sends EOF.
<3> Parse the incoming buffer

== Efficiently handling the received command handling the received command

You can use this snipped to quickly read a command.

[source,rust]
----
let command = read_command(stream);
match command {
    redisish::Command::Publish(message) => {

    }
    redisish::Command::Retrieve => {

    }
}
}
----

3. Implement multithreading
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Per connection:

1.  spawn a thread using `std::thread::spawn`
2.  wrap the `VecDeque` in a `std::sync::Mutex` and an `std::sync::Arc`
to pass it around
